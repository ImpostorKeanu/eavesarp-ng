package eavesarp_ng

import (
	"bytes"
	"database/sql"
	"errors"
	"fmt"
	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/google/gopacket/pcap"
	"net"
	"os"
)

var (
	stopSnifferC = make(chan bool)
)

func Sniff(db *sql.DB) {
	// SOURCE: https://github.com/google/gopacket/blob/master/examples/arpscan/arpscan.go

	defer db.Close()
	go ArpSender()
	defer func() {
		// TODO
		println("killing arp sender process")
		stopArpSenderC <- true
	}()

	go DnsSender()
	defer func() {
		// TODO
		println("killing dns sender process")
		stopDnsSenderC <- true
	}()

	//==========================
	// PREPARE NETWORK INTERFACE
	//==========================

	iface, err := net.InterfaceByName("enp13s0")
	if err != nil {
		// TODO
		println("error looking up network interface: ", err.Error())
		os.Exit(1)
	}

	var addr *net.IPNet
	if addrs, err := iface.Addrs(); err != nil {
		// TODO
		println("failed to obtain ip address from network interface: ", err.Error())
		os.Exit(1)
	} else {
		for _, a := range addrs {
			if n, ok := a.(*net.IPNet); ok && !n.IP.IsLoopback() {
				if ip4 := n.IP.To4(); ip4 != nil {
					addr = &net.IPNet{
						IP:   ip4,
						Mask: n.Mask[len(n.Mask)-4:],
					}
				}
			}
		}
	}

	//============================
	// PERPETUALLY CAPTURE PACKETS
	//============================

	println("starting packet capture")

	handle, err := pcap.OpenLive(iface.Name, 65536, true, pcap.BlockForever)
	if err != nil {
		// TODO
		println("error opening packet capture: ", err.Error())
		os.Exit(1)
	}

	src := gopacket.NewPacketSource(handle, layers.LayerTypeEthernet)
	in := src.Packets()

	for {
		var packet gopacket.Packet
		select {
		case <-stopSnifferC:
			return
		case packet = <-in:

			arpLayer := packet.Layer(layers.LayerTypeARP)
			if arpLayer == nil {
				continue
			}
			arp := arpLayer.(*layers.ARP)

			// Ignore ARP requests generated by our interface
			// TODO this should probably check all interfaces, not just the one
			//      we're sniffing
			if bytes.Equal(iface.HardwareAddr, arp.SourceHwAddress) {
				continue
			}

			u := newUnpackedArp(arp)

			switch arp.Operation {
			case layers.ARPRequest:

				//======================================
				// HANDLE PASSIVELY CAPTURED ARP REQUEST
				//======================================

				fmt.Printf("ARP Request: %s (%s) -> %s\n", u.SrcIp, u.SrcHw, u.DstIp)

				_, srcIp, dstIp, err := u.getOrCreateSnifferDbValues(db, PassiveArpMeth)
				// TODO log new IP discoveries

				if dstIp.MacId == nil && !activeArps.Has(dstIp.Value) && !dstIp.ArpResolved {

					//=================
					// SEND ARP REQUEST
					//=================

					arpSenderC <- ArpSenderArgs{
						handle:   handle,
						srcIface: iface,
						addr:     addr,
						dstIp:    arp.DstProtAddress,
						addActiveArp: func() (err error) {
							err = activeArps.Add(dstIp, func() error { return SetArpResolved(db, dstIp.Id) })
							if err != nil && !errors.Is(err, activeArpAlreadySet) {
								// TODO logging
								println("failed to watch for active arp response", err.Error())
								os.Exit(1)
							} else if err != nil {
								err = nil
							}
							return
						},
					}

					fmt.Printf("initiated active arp request for %v\n", dstIp.Value)
				}

				//====================
				// INCREMENT ARP COUNT
				//====================

				count, err := IncArpCount(db, srcIp.Id, dstIp.Id)
				if err != nil {
					// TODO
					println("failed to increment arp count: ", err.Error())
					os.Exit(1)
				}
				fmt.Printf("Incremented arp count: %s -> %s -> %d\n", srcIp.Value, dstIp.Value, count)

				//===================
				// DO NAME RESOLUTION
				//===================

				if !dnsFailCounter.Exceeded() {
					for _, ip := range []*Ip{srcIp, dstIp} {
						if !ip.PtrResolved {
							dnsSenderC <- DnsSenderArgs{
								kind:   PtrDnsKind,
								target: ip.Value,
								failure: func(e error) {
									if err := SetPtrResolved(db, *ip); err != nil {
										// TODO
										println("failed to set ptr to resolved: ", err.Error())
										os.Exit(1)
									}
								},
								after: func(names []string) {
									for _, name := range names {
										handlePtrName(db, ip, name, nil)
									}
								},
							}
						}
					}
				}

			case layers.ARPReply:

				//===================
				// HANDLE ARP REPLIES
				//===================

				fmt.Printf("ARP Response: %s (%s) -> %s (%s)\n", u.SrcIp, u.SrcHw, u.DstIp, u.DstHw)

				if ip := activeArps.Get(u.SrcIp); ip != nil {
					srcMac, srcIp, _, err := u.getOrCreateSnifferDbValues(db, ActiveArpMeth)
					if err != nil {
						// TODO
						println("failed to handle arp reply: ", err.Error())
						os.Exit(1)
					}
					fmt.Printf("received arp reply: %s (%s)\n", srcIp.Value, srcMac.Value)
				}
			}
		}
	}
}

func (u unpackedArp) getOrCreateSnifferDbValues(db *sql.DB, arpMethod DiscMethod) (srcMac *Mac, srcIp *Ip,
  dstIp *Ip, err error) {

	//===============
	// HANDLE SRC MAC
	//===============

	srcMacBuff, err := GetOrCreateMac(db, u.SrcHw, arpMethod)
	if err != nil {
		// TODO
		println("failed to create mac: ", err.Error())
		os.Exit(1)
	}
	srcMac = &srcMacBuff

	//==============
	// HANDLE SRC IP
	//==============

	srcIpBuff, err := GetOrCreateIp(db, u.SrcIp, &srcMacBuff.Id, arpMethod, true, false)
	if err != nil {
		// TODO
		println("failed to create mac: ", err.Error())
		os.Exit(1)
	} else if srcIpBuff.MacId == nil {

		//============
		// SET SRC MAC
		//============
		// - the mac is unavailable when a _target_ IP address was discovered via ARP request
		// - since goc doesn't update records, this means we'll need to update it manually

		if _, err = db.Exec(`UPDATE ip SET mac_id=? WHERE id=?`, srcMac.Id, srcIpBuff.Id); err != nil {
			println("failed to update ip with mac address: ", err.Error())
			os.Exit(1)
		}
		srcIpBuff.MacId = &srcMac.Id
	}
	srcIp = &srcIpBuff

	if arpMethod == PassiveArpMeth {
		dstIpBuff, err := GetOrCreateIp(db, u.DstIp, nil, arpMethod, false, false)
		if err != nil {
			// TODO
			println("failed to create mac: ", err.Error())
			os.Exit(1)
		}
		dstIp = &dstIpBuff
	}

	return
}
