package main

import (
	"fmt"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	zone "github.com/lrstanley/bubblezone"
	"strings"
)

var (
	btnStyle               = lipgloss.NewStyle().Background(lipgloss.Color("241")).AlignHorizontal(lipgloss.Center)
	focusedStyle           = lipgloss.NewStyle()
	blurredStyle           = lipgloss.NewStyle().Foreground(lipgloss.Color("240"))
	underlineStyle         = lipgloss.NewStyle().Underline(true)
	captureDurationHeading = underlineStyle.Render("Capture Duration")
	packetLimitHeading     = underlineStyle.Render("Packet Limit")
	outputFileHeading      = underlineStyle.Render("Output File")
)

const (
	captureDurationInputIndex = iota
	packetLimitInputIndex
	outputFileInputIndex
)

const (
	startBtnMark      = "startBtn"
	cancelBtnMark     = "cancelBtn"
	CancelConfigEvent = "CancelConfigEvent"
	CancelPoisonEvent = "CancelPoisonEvent"
	StartPoisonEvent  = "StartPoisonEvent"
)

type (
	// PoisonPanel is the poisoning configuration form presented
	// after the user has elected to begin the poisoning process
	// for a given SNAC conversation.
	//
	// New should always be used to initialize this type to ensure
	// a unique identifier is created for each button.
	//
	// Use Id to obtain the randomly created identifier.
	PoisonPanel struct {
		Style                lipgloss.Style    // Style for the panel element
		Width, Height        int               // Width and Height for the element
		id                   string            // random id created by New
		inputs               []textinput.Model // text input fields
		inputFocusIndex      int               // track which input has focus
		running              bool              // indicates if the poisoning attack is running
		startBtnMark         string            // unique zone mark for this panel's start button
		cancelBtnMark        string            // unique zone mark for this panel's cancel button
		cancelConfigBtnPress BtnPressMsg       // created by New
		cancelPoisonBtnPress BtnPressMsg       // created by New
		startPoisonBtnPress  BtnPressMsg       // created by New
		zoneM                *zone.Manager     // created by New
	}

	// BtnPressMsg indicates a button has been pressed in a PoisonPanel.
	BtnPressMsg struct {
		Id    string // Id of the panel that emitted the event
		Event string // Event that was emitted
	}
)

func New() PoisonPanel {
	z := zone.New()
	id := z.NewPrefix()
	return PoisonPanel{
		zoneM:                z,
		inputs:               newTextInputs(),
		id:                   id,
		startBtnMark:         fmt.Sprintf("%s-%s", id, startBtnMark),
		cancelBtnMark:        fmt.Sprintf("%s-%s", id, cancelBtnMark),
		cancelConfigBtnPress: BtnPressMsg{id, CancelConfigEvent},
		cancelPoisonBtnPress: BtnPressMsg{id, CancelPoisonEvent},
		startPoisonBtnPress:  BtnPressMsg{id, StartPoisonEvent},
	}
}

// Id returns the ID value that was randomly generated by New.
func (p PoisonPanel) Id() string {
	return p.id
}

func newTextInputs() []textinput.Model {
	cDur := textinput.New()
	cDur.PromptStyle = focusedStyle
	cDur.TextStyle = focusedStyle
	cDur.Placeholder = "Blank to capture forever or 10m, 1h, etc."
	cDur.Focused()

	pLim := textinput.New()
	pLim.Placeholder = "Integer or blank for no limit"
	pLim.PromptStyle = blurredStyle
	pLim.TextStyle = blurredStyle

	oF := textinput.New()
	oF.Placeholder = "Absolute path or blank to not save"
	oF.PromptStyle = blurredStyle
	oF.TextStyle = blurredStyle

	return []textinput.Model{cDur, pLim, oF}
}

func (p PoisonPanel) PacketLimitInput() textinput.Model {
	return p.inputs[packetLimitInputIndex]
}

func (p PoisonPanel) CaptureDurationInput() textinput.Model {
	return p.inputs[captureDurationInputIndex]
}

func (p PoisonPanel) OutputFileInput() textinput.Model {
	return p.inputs[outputFileInputIndex]
}

func (p PoisonPanel) Init() tea.Cmd {
	p.inputs[0].Focus()
	return textinput.Blink
}

func (p PoisonPanel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.MouseMsg:
		if msg.Action == tea.MouseActionRelease && msg.Button == tea.MouseButtonLeft {

			if p.zoneM.Get(p.cancelBtnMark).InBounds(msg) {

				// May need to cancel configuration before starting an attack
				if p.running {
					// Cancel a running attack
					p.running = false
					p.inputs[p.inputFocusIndex].Focus()
					p.inputs[p.inputFocusIndex].TextStyle = focusedStyle
					p.inputs[p.inputFocusIndex].PromptStyle = focusedStyle
					return p, func() tea.Msg {
						// Notify that poisoning should be canceled
						return p.cancelPoisonBtnPress
					}
				}

				p.inputFocusIndex = 0
				p.inputs = newTextInputs()
				p.inputs[captureDurationInputIndex].Focus()

				// Cancel poisoning configuration
				return p, func() tea.Msg {
					// Notify that configuration should stop
					return p.cancelConfigBtnPress
				}

			} else if p.zoneM.Get(p.startBtnMark).InBounds(msg) {

				p.running = true
				p.inputs[p.inputFocusIndex].Blur()
				p.inputs[p.inputFocusIndex].TextStyle = blurredStyle
				p.inputs[p.inputFocusIndex].PromptStyle = blurredStyle
				return p, func() tea.Msg {
					// Notify that poisoning should start
					return p.startPoisonBtnPress
				}

			}
		}
	case tea.KeyMsg:
		switch msg.String() {
		case "tab", "shift+tab":

			if p.running {
				// Preserve inputs while runs
				break
			}

			if msg.String() == "tab" {
				// Move forward
				p.inputFocusIndex++
			} else {
				// Move backward
				p.inputFocusIndex--
			}

			if p.inputFocusIndex == len(p.inputs) {
				// Return to first input
				p.inputFocusIndex = 0
			} else if p.inputFocusIndex < 0 {
				// Jump to last input
				p.inputFocusIndex = len(p.inputs) - 1
			}

			cmds := make([]tea.Cmd, len(p.inputs))
			for i := 0; i <= len(p.inputs)-1; i++ {
				if i == p.inputFocusIndex {
					// Set focused state
					cmds[i] = p.inputs[i].Focus()
					p.inputs[i].PromptStyle = focusedStyle
					p.inputs[i].TextStyle = focusedStyle
					continue
				}
				// Remove focused state
				p.inputs[i].Blur()
				p.inputs[i].PromptStyle = blurredStyle
				p.inputs[i].TextStyle = blurredStyle
			}

			return p, tea.Batch(cmds...)
		}
	}

	return p, p.updateInputs(msg)
}

func (p *PoisonPanel) updateInputs(msg tea.Msg) tea.Cmd {
	cmds := make([]tea.Cmd, len(p.inputs))

	// Only text inputs with Focus() set will respond, so it's safe to simply
	// update all of them here without any further logic.
	for i := range p.inputs {
		p.inputs[i], cmds[i] = p.inputs[i].Update(msg)
	}

	return tea.Batch(cmds...)
}

func (p PoisonPanel) View() string {
	var builder strings.Builder

	for i := range p.inputs {
		switch i {
		case captureDurationInputIndex:
			builder.WriteString(captureDurationHeading)
		case packetLimitInputIndex:
			builder.WriteString(packetLimitHeading)
		case outputFileInputIndex:
			builder.WriteString(outputFileHeading)
		default:
			// TODO
			panic("heading offset exceeded")
		}
		builder.WriteString("\n" + p.inputs[i].View() + "\n\n")
	}

	s := p.Style.Width(p.Width).Height(p.Height)

	if p.running {
		// Only show cancel button
		builder.WriteString(p.zoneM.Mark(p.cancelBtnMark, btnStyle.Width(s.GetWidth()).Render("Cancel Poisoning")))
	} else {
		// Show start and cancel button
		w := s.GetWidth() / 2
		builder.WriteString(lipgloss.JoinHorizontal(lipgloss.Center,
			p.zoneM.Mark(p.startBtnMark, btnStyle.Width(w-1).
				PaddingRight(1).
				MarginRight(1).
				Render("Start")),
			p.zoneM.Mark(p.cancelBtnMark, btnStyle.Width(w).
				Render("Cancel Configuration"))))
	}

	return p.zoneM.Scan(s.Render(builder.String()))
}

func main() {
	p := New()
	p.Style = lipgloss.NewStyle().Border(lipgloss.NormalBorder(), true, true, true, true)
	p.Height = 10
	p.Width = 70
	if _, err := tea.NewProgram(p, tea.WithAltScreen(), tea.WithMouseCellMotion()).Run(); err != nil {
		fmt.Printf("error starting the ui: %v", err.Error())
	}
}
