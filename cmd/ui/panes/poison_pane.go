package panes

import (
	"errors"
	"fmt"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/enescakir/emoji"
	zone "github.com/lrstanley/bubblezone"
	"os"
	"path"
	"strconv"
	"strings"
	"time"
)

var (
	btnStyle               = lipgloss.NewStyle().Background(lipgloss.Color("241")).AlignHorizontal(lipgloss.Center).PaddingLeft(1).PaddingRight(1)
	focusedStyle           = lipgloss.NewStyle()
	blurredStyle           = lipgloss.NewStyle().Foreground(lipgloss.Color("240"))
	underlineStyle         = lipgloss.NewStyle().Underline(true)
	validationFailureStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("#e60000"))
	validationSuccessStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("#009900"))
	captureDurationHeading = underlineStyle.Render("Capture Duration")
	packetLimitHeading     = underlineStyle.Render("Packet Limit")
	outputFileHeading      = underlineStyle.Render("Output File")
	validators             = []validator{validateDuration, validatePacketLimit, validateOutputFile}
)

const (
	captureDurationInputIndex = iota
	packetLimitInputIndex
	outputFileInputIndex
)

const (
	startBtnMark      = "startBtn"
	cancelBtnMark     = "cancelBtn"
	CancelConfigEvent = "CancelConfigEvent"
	CancelPoisonEvent = "CancelPoisonEvent"
	StartPoisonEvent  = "StartPoisonEvent"
)

type (
	// PoisonPane is the poisoning configuration form presented
	// after the user has elected to begin poisoning a SNAC conversation.
	//
	// NewPoison should always be used to initialize this type to ensure
	// creation of unique identifiers.
	//
	// Use Id to obtain the randomly created identifier.
	PoisonPane struct {
		Style             lipgloss.Style    // Style for the panel element
		paneHeadingZoneId string            // To make the pane's "Poisoning" heading clickable
		id                string            // random id created by NewPoison
		inputs            []textinput.Model // text input fields
		errors            []string          // error messages for inputs
		inputFocusIndex   int               // track which input has focus
		running           bool              // determines if the poisoning attack is running
		startBtnMark      string            // unique zone mark for this panel's start button
		cancelBtnMark     string            // unique zone mark for this panel's cancel button
		zoneM             *zone.Manager     // created by NewPoison
	}

	// BtnPressMsg indicates a button has been pressed in a PoisonPane.
	BtnPressMsg struct {
		Event    string // Event that was emitted
		FormData FormData
	}

	FormData struct {
		CaptureDuration, PacketLimit, OutputFile string
	}

	validator func(string) error
)

func NewPoison(z *zone.Manager, paneHeadingZoneId string) PoisonPane {
	id := z.NewPrefix()
	return PoisonPane{
		zoneM:         z,
		inputs:        newTextInputs(),
		id:            id,
		startBtnMark:  fmt.Sprintf("%s-%s", id, startBtnMark),
		cancelBtnMark: fmt.Sprintf("%s-%s", id, cancelBtnMark),
	}
}

func validatePacketLimit(v string) (err error) {
	if v == "" {
		return
	} else if i, e := strconv.Atoi(v); e != nil {
		err = errors.New("invalid packet limit")
	} else if i < 1 {
		err = errors.New("packet limit must be > 0")
	}
	return
}

func validateDuration(v string) (err error) {
	if v == "" {
		return
	} else if _, e := time.ParseDuration(v); e != nil {
		err = errors.New("poorly formatted duration")
	}
	return
}

func validateOutputFile(v string) (err error) {
	if v == "" {
		return
	}

	// does the file already exist?
	if fI, e := os.Stat(v); os.IsNotExist(e) {
		// if not, is does the directory exist
		d, _ := path.Split(v)
		if fI, e = os.Stat(d); d != "" && os.IsNotExist(e) {
			err = errors.New("parent directory doesn't exist")
		}
	} else if !fI.IsDir() {
		err = errors.New("file already exists")
	}
	return
}

// Id returns the ID value that was randomly generated by NewPoison.
func (p PoisonPane) Id() string {
	return p.id
}

func newTextInputs() []textinput.Model {
	cDur := textinput.New()
	cDur.PromptStyle = focusedStyle
	cDur.TextStyle = focusedStyle
	cDur.Placeholder = "Blank to capture forever or 10m, 1h, etc."
	cDur.Focus()

	pLim := textinput.New()
	pLim.Placeholder = "Integer or blank for no limit"
	pLim.PromptStyle = blurredStyle
	pLim.TextStyle = blurredStyle

	oF := textinput.New()
	oF.Placeholder = "Absolute path or blank to not save"
	oF.PromptStyle = blurredStyle
	oF.TextStyle = blurredStyle

	return []textinput.Model{cDur, pLim, oF}
}

func (p PoisonPane) PacketLimitInput() textinput.Model {
	return p.inputs[packetLimitInputIndex]
}

func (p PoisonPane) CaptureDurationInput() textinput.Model {
	return p.inputs[captureDurationInputIndex]
}

func (p PoisonPane) OutputFileInput() textinput.Model {
	return p.inputs[outputFileInputIndex]
}

func (p PoisonPane) Init() tea.Cmd {
	p.inputs[0].Focus()
	return nil
}

func (p PoisonPane) FormData() FormData {
	return FormData{
		CaptureDuration: p.CaptureDurationInput().Value(),
		PacketLimit:     p.PacketLimitInput().Value(),
		OutputFile:      p.OutputFileInput().Value(),
	}
}

func (p PoisonPane) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.MouseMsg:
		if msg.Action == tea.MouseActionRelease && msg.Button == tea.MouseButtonLeft {

			if p.zoneM.Get(p.cancelBtnMark).InBounds(msg) {

				// May need to cancel configuration before starting an attack
				if p.running {
					// Cancel a running attack
					p.running = false
					p.inputs[p.inputFocusIndex].Focus()
					p.inputs[p.inputFocusIndex].TextStyle = focusedStyle
					p.inputs[p.inputFocusIndex].PromptStyle = focusedStyle
					return p, func() tea.Msg {
						// Notify that poisoning should be canceled
						return BtnPressMsg{
							Event:    CancelPoisonEvent,
							FormData: p.FormData(),
						}
					}
				}

				p.inputFocusIndex = 0
				p.inputs = newTextInputs()
				p.inputs[captureDurationInputIndex].Focus()
				return p, func() tea.Msg {
					// Notify that configuration should stop
					return BtnPressMsg{
						Event:    CancelConfigEvent,
						FormData: p.FormData(),
					}
				}

			} else if p.zoneM.Get(p.startBtnMark).InBounds(msg) {
				// Start button clicked
				p.running = true
				p.inputs[p.inputFocusIndex].Blur()
				p.inputs[p.inputFocusIndex].TextStyle = blurredStyle
				p.inputs[p.inputFocusIndex].PromptStyle = blurredStyle
				return p, func() tea.Msg {
					// Notify that poisoning should start
					return BtnPressMsg{
						Event:    StartPoisonEvent,
						FormData: p.FormData(),
					}
				}
			}
		}

	case tea.KeyMsg:
		switch msg.String() {
		case "tab", "shift+tab":

			if p.running {
				// Preserve inputs while runs
				break
			}

			if msg.String() == "tab" {
				// Move forward
				p.inputFocusIndex++
			} else {
				// Move backward
				p.inputFocusIndex--
			}

			if p.inputFocusIndex == len(p.inputs) {
				// Return to first input
				p.inputFocusIndex = 0
			} else if p.inputFocusIndex < 0 {
				// Jump to last input
				p.inputFocusIndex = len(p.inputs) - 1
			}

			cmds := make([]tea.Cmd, len(p.inputs)+1)
			for i := 0; i <= len(p.inputs)-1; i++ {
				if i == p.inputFocusIndex {
					// Set focused state
					cmds[i] = p.inputs[i].Focus()
					p.inputs[i].PromptStyle = focusedStyle
					p.inputs[i].TextStyle = focusedStyle
					continue
				}
				// Remove focused state
				p.inputs[i].Blur()
				p.inputs[i].PromptStyle = blurredStyle
				p.inputs[i].TextStyle = blurredStyle
			}

			return p, tea.Batch(cmds...)
		}
	}

	return p, p.updateInputs(msg)
}

func (p *PoisonPane) updateInputs(msg tea.Msg) tea.Cmd {
	cmds := make([]tea.Cmd, len(p.inputs))

	// Only text inputs with Focus() set will respond, so it's safe to simply
	// update all of them here without any further logic.
	for i := range p.inputs {
		p.inputs[i], cmds[i] = p.inputs[i].Update(msg)
	}

	return tea.Batch(cmds...)
}

func (p *PoisonPane) SetHeight(h int) {
	p.Style = p.Style.Height(h - 2)
}

func (p *PoisonPane) SetWidth(w int) {
	p.Style = p.Style.Width(w)
}

func (p PoisonPane) View() string {
	var hasErrors bool
	var builder strings.Builder

	for i := range p.inputs {
		err := validators[i](p.inputs[i].Value())
		switch i {
		case captureDurationInputIndex:
			builder.WriteString(captureDurationHeading)
		case packetLimitInputIndex:
			builder.WriteString(packetLimitHeading)
		case outputFileInputIndex:
			builder.WriteString(outputFileHeading)
		default:
			// TODO
			panic("heading offset exceeded")
		}

		builder.WriteString(" ")
		if err != nil {
			builder.WriteString(validationFailureStyle.Render(err.Error()))
			if !hasErrors {
				hasErrors = true
			}
		} else if p.running {
			builder.WriteString(emoji.Locked.String())
		} else {
			builder.WriteString(validationSuccessStyle.Render("âœ”"))
		}
		builder.WriteString("\n" + p.inputs[i].View())
		if i < len(p.inputs)-1 {
			builder.WriteString("\n\n")
		}
	}

	for btnPad := p.Style.GetHeight() - lipgloss.Height(builder.String()); btnPad > 1; btnPad-- {
		builder.WriteString("\n")
	}

	centerStyle := lipgloss.NewStyle().AlignHorizontal(lipgloss.Center).Width(p.Style.GetWidth())
	if p.running || hasErrors {
		// Show only the cancel button
		builder.WriteString(
			centerStyle.Render(p.zoneM.Mark(p.cancelBtnMark, btnStyle.Render("Cancel Poisoning"))))
	} else {
		// Show start and cancel button
		//btnStyle := btnStyle.Width((p.Style.GetMaxWidth() - 3) / 2)

		builder.WriteString(centerStyle.Render(lipgloss.JoinHorizontal(lipgloss.Center,
			p.zoneM.Mark(p.startBtnMark, btnStyle.MarginRight(1).Render("Start")),
			p.zoneM.Mark(p.cancelBtnMark, btnStyle.Render("Cancel")))))
	}

	return p.Style.Render(centerStyle.Render(p.zoneM.Mark(p.paneHeadingZoneId, "Poisoning")), builder.String())
}
