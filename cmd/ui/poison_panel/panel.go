package poison_panel

import (
	"errors"
	"fmt"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	zone "github.com/lrstanley/bubblezone"
	"os"
	"path"
	"strconv"
	"strings"
	"time"
)

var (
	btnStyle               = lipgloss.NewStyle().Background(lipgloss.Color("241")).AlignHorizontal(lipgloss.Center)
	focusedStyle           = lipgloss.NewStyle()
	blurredStyle           = lipgloss.NewStyle().Foreground(lipgloss.Color("240"))
	underlineStyle         = lipgloss.NewStyle().Underline(true)
	validationFailureStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("#e60000"))
	validationSuccessStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("#009900"))
	captureDurationHeading = underlineStyle.Render("Capture Duration")
	packetLimitHeading     = underlineStyle.Render("Packet Limit")
	outputFileHeading      = underlineStyle.Render("Output File")
	validators             = []validator{validateDuration, validatePacketLimit, validateOutputFile}
)

const (
	captureDurationInputIndex = iota
	packetLimitInputIndex
	outputFileInputIndex
)

const (
	startBtnMark      = "startBtn"
	cancelBtnMark     = "cancelBtn"
	CancelConfigEvent = "CancelConfigEvent"
	CancelPoisonEvent = "CancelPoisonEvent"
	StartPoisonEvent  = "StartPoisonEvent"
)

type (
	// PoisonPanel is the poisoning configuration form presented
	// after the user has elected to begin the poisoning process
	// for a given SNAC conversation.
	//
	// New should always be used to initialize this type to ensure
	// a unique identifier is created for each button.
	//
	// Use Id to obtain the randomly created identifier.
	PoisonPanel struct {
		Style                lipgloss.Style    // Style for the panel element
		Width, Height        int               // Width and Height for the element
		id                   string            // random id created by New
		inputs               []textinput.Model // text input fields
		errors               []string          // error messages for inputs
		inputFocusIndex      int               // track which input has focus
		running              bool              // indicates if the poisoning attack is running
		startBtnMark         string            // unique zone mark for this panel's start button
		cancelBtnMark        string            // unique zone mark for this panel's cancel button
		cancelConfigBtnPress BtnPressMsg       // created by New
		cancelPoisonBtnPress BtnPressMsg       // created by New
		startPoisonBtnPress  BtnPressMsg       // created by New
		zoneM                *zone.Manager     // created by New
	}

	// BtnPressMsg indicates a button has been pressed in a PoisonPanel.
	BtnPressMsg struct {
		Id    string // Id of the panel that emitted the event
		Event string // Event that was emitted
	}

	validator func(string) error
)

func New() PoisonPanel {
	z := zone.New()
	id := z.NewPrefix()
	return PoisonPanel{
		zoneM:                z,
		inputs:               newTextInputs(),
		id:                   id,
		startBtnMark:         fmt.Sprintf("%s-%s", id, startBtnMark),
		cancelBtnMark:        fmt.Sprintf("%s-%s", id, cancelBtnMark),
		cancelConfigBtnPress: BtnPressMsg{id, CancelConfigEvent},
		cancelPoisonBtnPress: BtnPressMsg{id, CancelPoisonEvent},
		startPoisonBtnPress:  BtnPressMsg{id, StartPoisonEvent},
	}
}

func validatePacketLimit(v string) (err error) {
	if v == "" {
		return
	} else if i, e := strconv.Atoi(v); e != nil {
		err = errors.New("invalid packet limit")
	} else if i < 1 {
		err = errors.New("packet limit must be > 0")
	}
	return
}

func validateDuration(v string) (err error) {
	if v == "" {
		return
	} else if _, e := time.ParseDuration(v); e != nil {
		err = errors.New("poorly formatted duration")
	}
	return
}

func validateOutputFile(v string) (err error) {
	if v == "" {
		return
	}

	// does the file already exist?
	if fI, e := os.Stat(v); os.IsNotExist(e) {
		// if not, is does the directory exist
		d, _ := path.Split(v)
		if fI, e = os.Stat(d); d != "" && os.IsNotExist(e) {
			err = errors.New("parent directory doesn't exist")
		}
	} else if !fI.IsDir() {
		err = errors.New("file already exists")
	}
	return
}

// Id returns the ID value that was randomly generated by New.
func (p PoisonPanel) Id() string {
	return p.id
}

func newTextInputs() []textinput.Model {
	cDur := textinput.New()
	cDur.PromptStyle = focusedStyle
	cDur.TextStyle = focusedStyle
	cDur.Placeholder = "Blank to capture forever or 10m, 1h, etc."
	cDur.Focused()

	pLim := textinput.New()
	pLim.Placeholder = "Integer or blank for no limit"
	pLim.PromptStyle = blurredStyle
	pLim.TextStyle = blurredStyle

	oF := textinput.New()
	oF.Placeholder = "Absolute path or blank to not save"
	oF.PromptStyle = blurredStyle
	oF.TextStyle = blurredStyle

	return []textinput.Model{cDur, pLim, oF}
}

func (p PoisonPanel) PacketLimitInput() textinput.Model {
	return p.inputs[packetLimitInputIndex]
}

func (p PoisonPanel) CaptureDurationInput() textinput.Model {
	return p.inputs[captureDurationInputIndex]
}

func (p PoisonPanel) OutputFileInput() textinput.Model {
	return p.inputs[outputFileInputIndex]
}

func (p PoisonPanel) Init() tea.Cmd {
	p.inputs[0].Focus()
	return textinput.Blink
}

func (p PoisonPanel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.MouseMsg:
		if msg.Action == tea.MouseActionRelease && msg.Button == tea.MouseButtonLeft {

			if p.zoneM.Get(p.cancelBtnMark).InBounds(msg) {

				// May need to cancel configuration before starting an attack
				if p.running {
					// Cancel a running attack
					p.running = false
					p.inputs[p.inputFocusIndex].Focus()
					p.inputs[p.inputFocusIndex].TextStyle = focusedStyle
					p.inputs[p.inputFocusIndex].PromptStyle = focusedStyle
					return p, func() tea.Msg {
						// Notify that poisoning should be canceled
						return p.cancelPoisonBtnPress
					}
				}

				p.inputFocusIndex = 0
				p.inputs = newTextInputs()
				p.inputs[captureDurationInputIndex].Focus()

				// Cancel poisoning configuration
				return p, func() tea.Msg {
					// Notify that configuration should stop
					return p.cancelConfigBtnPress
				}

			} else if p.zoneM.Get(p.startBtnMark).InBounds(msg) {

				p.running = true
				p.inputs[p.inputFocusIndex].Blur()
				p.inputs[p.inputFocusIndex].TextStyle = blurredStyle
				p.inputs[p.inputFocusIndex].PromptStyle = blurredStyle
				return p, func() tea.Msg {
					// Notify that poisoning should start
					return p.startPoisonBtnPress
				}

			}
		}
	case tea.KeyMsg:
		switch msg.String() {
		case "tab", "shift+tab":

			if p.running {
				// Preserve inputs while runs
				break
			}

			if msg.String() == "tab" {
				// Move forward
				p.inputFocusIndex++
			} else {
				// Move backward
				p.inputFocusIndex--
			}

			if p.inputFocusIndex == len(p.inputs) {
				// Return to first input
				p.inputFocusIndex = 0
			} else if p.inputFocusIndex < 0 {
				// Jump to last input
				p.inputFocusIndex = len(p.inputs) - 1
			}

			cmds := make([]tea.Cmd, len(p.inputs))
			for i := 0; i <= len(p.inputs)-1; i++ {
				if i == p.inputFocusIndex {
					// Set focused state
					cmds[i] = p.inputs[i].Focus()
					p.inputs[i].PromptStyle = focusedStyle
					p.inputs[i].TextStyle = focusedStyle
					continue
				}
				// Remove focused state
				p.inputs[i].Blur()
				p.inputs[i].PromptStyle = blurredStyle
				p.inputs[i].TextStyle = blurredStyle
			}

			return p, tea.Batch(cmds...)
		}
	}

	return p, p.updateInputs(msg)
}

func (p *PoisonPanel) updateInputs(msg tea.Msg) tea.Cmd {
	cmds := make([]tea.Cmd, len(p.inputs))

	// Only text inputs with Focus() set will respond, so it's safe to simply
	// update all of them here without any further logic.
	for i := range p.inputs {
		p.inputs[i], cmds[i] = p.inputs[i].Update(msg)
	}

	return tea.Batch(cmds...)
}

func (p PoisonPanel) View() string {
	var hasErrors bool
	var builder strings.Builder

	for i := range p.inputs {
		err := validators[i](p.inputs[i].Value())
		switch i {
		case captureDurationInputIndex:
			builder.WriteString(captureDurationHeading)
		case packetLimitInputIndex:
			builder.WriteString(packetLimitHeading)
		case outputFileInputIndex:
			builder.WriteString(outputFileHeading)
		default:
			// TODO
			panic("heading offset exceeded")
		}

		if err != nil {
			builder.WriteString(validationFailureStyle.Render(
				fmt.Sprintf(" %s", err.Error())))
			if !hasErrors {
				hasErrors = true
			}
		} else {
			builder.WriteString(validationSuccessStyle.Render(" âœ“"))
		}
		builder.WriteString("\n" + p.inputs[i].View() + "\n\n")
	}

	s := p.Style.Width(p.Width).Height(p.Height)

	if p.running || hasErrors {
		// Only show cancel button
		builder.WriteString(p.zoneM.Mark(p.cancelBtnMark, btnStyle.Width(s.GetWidth()).Render("Cancel Poisoning")))
	} else {
		// Show start and cancel button
		w := s.GetWidth() / 2
		builder.WriteString(lipgloss.JoinHorizontal(lipgloss.Center,
			p.zoneM.Mark(p.startBtnMark, btnStyle.Width(w-1).
				PaddingRight(1).
				MarginRight(1).
				Render("Start")),
			p.zoneM.Mark(p.cancelBtnMark, btnStyle.Width(w).
				Render("Cancel Configuration"))))
	}

	return p.zoneM.Scan(s.Render(builder.String()))
}
